<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript">
	/* 
	 ​	자바 설계도(클래스) => 재사용성
	 class Product{
	 private String carname="pony";
	 public Product(){}
	 public Product(String carname){
	 this.carname= carname;
	 }
	 public void print(){
	 System.out.println(this.carname);
	 }
	 }

	 메모리 load ... (new)
	 Product p = new Product();
	 Product p2 = new Product("pony2");

	 p.print();
	 p2.print();
	 /////////////////////////////////////////////////////

	 javaScript >> 객체지향언어(OOP)

	 클래스 정의 4가지 방법

	 1. 프로토타입 방식 :  일반적인 클래스 제작 방법
	 인스턴스마다 공통된 메서드를 공유해서 사용하는 장점 
	 Jquery 도 prototype 방식으로 설계  prototype>>부모>>나의원형(원본)
	 //proto : 원본, 부모, 상위라는뜻

	 function 클래스이름() {//함수랑 클래스랑 구분하기위해서 이름을 첫글짜 대문자 소문자로씀 그리고 클래스는 안에 this. 들어감
	 this.프로퍼티1 = 초기값;
	 this.프로퍼티2 = 초기값;
	 }

	 클래스이름.prototype.메서드1 = function() {
	 }
	 클래스이름.prototype.메서드2 = function() {
	 }

	 var 인스턴스 = new 클래스이름(); 
	 var carObj = new Car();
	 var carObj2 = new Car();
	 var carObj3 = new Car();

	 ​

	 ​

	 2. 함수 방식 : 간단한 클래스 제작 시 사용 //그냥 객체가 함수를 가지고있음
	 인스턴스마다 메서드가 독립적으로 만들어지는 단점 //그래서 공유는못하지만 다쓸수있음
	
	 ** 클래스 :  function Car(){ this.name = , this.age=}
	 ** 함수 :   function car(){}

	 function 클래스이름() { 
	 this.프로퍼티1 = 초기값;
	 this.프로퍼티2 = 초기값;
	 this.메서드1 = function() {

	 }
	 this.메서드2 = function() {

	 }
	 }

	 var 인스턴스 = new 클래스이름(); 
	 var carObj = new Car();
	 var carObj2 = new Car();
	 var carObj3 = new Car();

	 ​

	 ​

	 ​
	 *****************
	 3. 리터럴 방식(JSON) : (*************************************)// 자바스크립트로 객체를 만드는 가장 간단한 방법
	 이기종간의 데이터 교환 표준임
	
	 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
	 정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나
	 (초보자에게도 중요 ^^)
	 *****************​

	 4. ECMA6 버전부터 : class 키워드 제공(2015년도 되서야...)
	 class Person {
	 constructor(name) {
	 this._name = name;
	 }
	 sayHi() {
	 console.log(`Hi! ${this._name}`);
	 }
	 }

	 ​

	 [ javascript 객체 생성 ]
	 1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요
	 1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열 
	 1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation

	 ex) var myObj = { "name":"John", "age":31, "city":"New York" };

	 TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
	 XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)

	 다른 이야기 >> JSON
	 객체지향언어 장점 : 설계도 (재사용성)
	 *오브젝트 리터럴 방식 : 재사용을 지원하는 않는다  //심플하려고
	 *설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
	 *설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
	 *설계도당 하나의 객체만 생성 사용 (only object)

	 // 빈객체​
	 var product = {};  //Product p = new Product();
	
	 var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};

	 var 인스턴스 ={
	 프로퍼티:초기값,
	 프로퍼티:초기값,
	 .....
	 메서드:function(){},
	 메서드:function(){}....
	 }

	 ​

	 리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
	 var 인스턴스 = {}
	 특징 : 생성자 존재하지 않는다.
	 프로퍼티와 메서드만 정의 가능
	 단점 : 객체 하나 생성(재사용성 없다) 
	 접근방법 : 인스턴스이름.자원 >> product2.제품명 

	 */
	//class Product {public String 제품명 = "사과" ....}
	// Product product = new Product();
	//product.제품명
	//이 세줄을...
	let product = {
		제품명 : "사과",
		년도 : "2000",
		원산지 : "대구"
	};//와 객체생성됨..

	console.log(product);
	document.write(product.제품명 + "<br>");
	document.write(product.년도 + "<br>");
	document.write(product.원산지 + "<br>");
	document.write(product.toString() + "<br>");

	//객체 만들기(JSON)
	let person = {
		name : "홍길동",
		addr : "서울시 강남구 역삼동",
		eat : function(food) {
			document.write(this.name + "/ " + this.addr + " / " + food + "냠냠");
		}//근데 보통 함수는 내부에 잘 안만듬 왜냐면 데이터만들어쓰는게 목적이라...
	}
	document.write("<hr>");
	person.eat("사과");
	document.write("<hr>");
	//1. 속성 제거 기능
	//let product = {제품명:"사과",년도:"2000",원산지:'대구'};
	delete (product.년도);
	console.log(product);

	//Array > for(let index in Array)

	for ( let key in product) {
		console.log(key);
		console.log(product[key]);
	}

	for ( let key in person) {
		console.log(person[key]);
	}
	//json 객체 활용
	//외부 API 제공(csv,xml,json 형태로 데이터 제공 : 공공데이터, 대법원판례 , 영화정보 , 날씨정보)
	//ex)서울시공공데이터 검색 ㄱㄱ
	// KEY POINT : 제공받은 xml, json 객체에서 원하는 속성만 추출해서 화면에 출력하는 작업을 할줄알면된다!!!!!!
	// 2차 강제사항 >> 최소 2개이상의 외부 API 사용하기 ...> 차트로 그리기 근데 차트도 외부API잇음 (highchart)

	//속성 추가도 가능
	let Member = {};
	Member.name = "hong"; //{name:"hong"}
	console.log(Member.name);

	Member.age = 100;
	Member.print = function() {
		document.write(this.name + " / " + this.age + "<br>");
	}

	Member.print();

	//POINT : 객체가 객체를 가질 수 있다, 객체가 배열을 가질 수 있다.
	// java class Member {Car car ; ArrayList list;}

	let Grade = {
		"list" : {
			"hong" : 10,
			"kim" : 20,
			"park" : 30
		},
		"show" : function() {
			for ( let key in this.list) {//함수내에선 무조껀 this.
				document.write(key + " : " + this.list[key] + "<br>");

			}
		}
	}
	Grade.show();
	document.write("<hr>");
	let listobj = Grade.list;//객체호출
	document.write(listobj.hong);//객체에서의 속성받기
	document.write("<br>");
	for(let key in listobj){
		document.write(key+" : "+listobj[key]+"<br>");
	}
</script>
</head>
<body>

</body>
</html>